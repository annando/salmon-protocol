#summary Proposed signature generation and validation mechanism.

= Introduction =

PROPOSAL: Salmon introduces a sal:signature element to be used for verifying the provenance of salmon comments.  This page provides details on the signature, its algorithm, and the motivations behind both.

The major issues around signing revolve around what is to be signed, and how to canonicalize the data to be signed in a portable and interoperable way.  Past experience has shown that canonicalization is a major stumbling block when writing code, especially code that relies on layers of libraries that may do nearly but not quite the right thing in all cases.  Unlike most cases on the Web, a single bit error results in a total failure, with little feedback allowed due to security concerns.  This also encourages the use of custom code to create signature base strings, which hurts interoperability and security (as every new line of code is a potential source of both interop and security bugs).

Salmon attempts to navigate between the sharp rocks of security on one hand, and the mucky shoals of interoperability on the other.

= Details =

The Salmon public key signature is a REQUIRED part of the protocol:  A salmon without a valid signature is invalid.  This is a key building block to preventing spam and abuse.  The signature can be verified by anyone, not just the source and aggregator.

In order to ensure interoperability, Salmon only signs a small, fixed set of fields.  This constrains the canonicalization problem.  The trade-off is that not all the content of a valid salmon can be fully trusted; essentially, only the provenance can be rigorously checked, the rest of the content can only be verified manually or heuristically.  

Salmon signs exactly 4 things using the author's public key:

  * The author's universally unique URI (atom:author/atom:uri) - Verifies the author's web identity.  It is assumed that key bits of identifying information such as name, image, etc. can be retrieved or double checked via discovery on the author/uri.
  * The globally unique URI of the salmon itself (atom:id, a URI) - Verifies that the author signed this particular entry and not some other.
  * The URL of the self link (link@rel="self") for the salmon - Provides a reliable URL to use to see the original salmon published at the aggregator.
  * The timestamp of the entry (atom:updated, an ISO8601 compatible Date construct, see RFC 4278) - Verifies that the author signed an entry at a particular time, helps make timestamps reliable.
  * The globally unique URI of the salmon's parent, the thing that the salmon is "about" or is in reply to (thr:in-reply-to) - Verifies the link in the distributed graph of replies.

These are carefully selected to be likely to survive transmission and re-publishing across many platforms.  All of the fields (and the signature hash itself) are 7 bit ASCII safe and have well defined canonical forms which have robust library support in the field already.

The Salmon signature lets anyone verify who created a salmon when, and provides unique IDs to help determine what they said.  Signing the IDs also lets us use IDs for purposes such as de-duping and heuristic content verification.  It is not possible to trivially erase someone else's salmon by forging a salmon ID.  However, it is possible for intermediaries such as aggregators to modify the textual content of the salmon to achieve the same effect; as a counterbalance, this forgery can be detected and traced to the offender using heuristics (an aggregator sees the supposedly-same content in the comment feed and can double check it).  Salmon's role is to guarantee message provenance, not integrity.

=== The Signature Algorithm ===

Creating the signature:

  # Take each of the values above and form a Signature Base String as in OAuth (see http://oauth.net/core/1.0, section 9), using simple string names (id, in-reply-to, self, updated, uri) as field names.
  # Sign as in OAuth (RSA-SHA1, or public key  - see OAuth section 9.3).  
  # The salmon signature string is the base64 representation of the output of the RSA-SHA1 algorithm (TODO: OK, so this really needs to be generalized, somebody with security expertise needs to hammer on this.)
  # Add a sal:signature element underneath the atom:entry which contains the salmon signature string:  {{{<sal:signature>base64( RSASSA-PKCS1-V1_5-SIGN (private_key,"id=xxyy&updated=kkee&uri=foo"") )</salmon:signature>}}}.  Leading and trailing whitespace may be used for formatting.  

Validation:

  # Calculate the Signature Base String as in "Creating the signature" above.
  # Perform RSASSA-PKCS1-V1_5-VERIFY(public_key, signature_base_string, base64decode(strip_whitespace(sal:signature))
  # If this returns "signature matches", the salmon is valid; else, it's invalid.
 
=== Discovering the Public Key ===

The private key of the author is assumed to be known to the aggregator in the usual case (but see DelegatedSigning).  However, the public key is not in general known to the source, so it must be discovered.  Thus, Salmon requires PKI, so we'll invent one.

Salmon requires author identity via a globally unique URI.  It also requires that this URI be discoverable via XRD / Webfinger, and that to participate in Salmon, each author identity must publish a public key linked to their URI.  (Note that a Webfinger URI may be an email like identifier.)  Thus, to find the public key, the source performs discovery on the author:uri, retrieves the current public key for that author, and uses that as the "public_key" in the validation step above.  (See SalmonPublicKeys for more details on the exact steps.)